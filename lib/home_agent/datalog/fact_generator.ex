defmodule HomeAgent.Datalog.FactGenerator do
  @moduledoc """
  GenServer that wakes up every `datalog_interval_ms` milliseconds,
  collects the current sensor state from StateStore and presence
  confidence from PresenceFusion cells, and writes a fresh Soufflé
  facts file to a temp path.

  The resulting file path is broadcast on PubSub topic `"datalog_facts"`
  so the RuleEngine can pick it up and evaluate.

  Epistemic categories (Winter's model) encoded as comments in the .dl:
    djuno  — ground-truth sensor readings (direct observation)
    jimpe  — derived structural relationships (time-of-day, etc.)
    jinvi  — fused confidence opinions (Bayesian output)
    krici  — axiomatic behavioral constraints (from beliefs.dl)
  """

  use GenServer
  require Logger

  alias HomeAgent.{RoomConfig, StateStore}
  alias HomeAgent.Propagator.{PresenceFusion, TimePeriod}

  @default_interval 5_000

  def start_link(_opts \\ []) do
    GenServer.start_link(__MODULE__, [], name: __MODULE__)
  end

  @doc "Generate facts immediately and return the file path."
  def generate_now do
    GenServer.call(__MODULE__, :generate_now, 15_000)
  end

  @doc """
  Build the Datalog facts string from current state.
  This is public so it can be called directly in tests without a running GenServer.
  """
  def build_facts do
    now = DateTime.utc_now()
    ts = DateTime.to_unix(now)
    period = TimePeriod.period_for(now)

    [
      header(),
      time_facts(ts, period),
      room_sensor_facts(ts),
      presence_confidence_facts()
    ]
    |> Enum.join("\n")
  end

  # --- GenServer callbacks ---

  @impl true
  def init([]) do
    interval = Application.get_env(:home_agent, :datalog_interval_ms, @default_interval)
    schedule(interval)
    {:ok, %{interval: interval}}
  end

  @impl true
  def handle_call(:generate_now, _from, state) do
    path = write_facts()
    {:reply, path, state}
  end

  @impl true
  def handle_info(:generate, state) do
    write_facts()
    schedule(state.interval)
    {:noreply, state}
  end

  # --- Private ---

  defp write_facts do
    content = build_facts()
    path = Path.join(System.tmp_dir!(), "ha_facts_#{System.system_time(:millisecond)}.dl")
    File.write!(path, content)
    HomeAgent.PubSub.broadcast(HomeAgent.PubSub, "datalog_facts", {:facts_ready, path})
    path
  end

  defp header do
    """
    // Auto-generated by HomeAgent.Datalog.FactGenerator
    // Timestamp: #{DateTime.utc_now() |> DateTime.to_iso8601()}
    //
    // djuno  = ground-truth sensor observations
    // jimpe  = structural/temporal relationships
    // jinvi  = fused confidence opinions
    """
  end

  defp time_facts(ts, period) do
    [
      "// jimpe — time context",
      ".decl time_period(period: symbol)",
      ".decl current_timestamp(ts: number)",
      "time_period(\"#{period}\").",
      "current_timestamp(#{ts})."
    ]
    |> Enum.join("\n")
  end

  defp room_sensor_facts(ts) do
    lines =
      ["// djuno — sensor readings",
       ".decl mmwave_active(room: symbol, ts: number)",
       ".decl pir_active(room: symbol, ts: number)",
       ".decl door_closed(room: symbol, ts: number)"]

    sensor_lines =
      Enum.flat_map(RoomConfig.rooms(), fn room ->
        mmwave_line =
          case RoomConfig.mmwave_entity(room) do
            nil -> []
            id -> if StateStore.on?(id), do: ["mmwave_active(\"#{room}\", #{ts})."], else: []
          end

        pir_line =
          case RoomConfig.pir_entity(room) do
            nil -> []
            id ->
              case StateStore.get(id) do
                {_state_str, _attrs, last_ts} ->
                  # PIR is considered active if the sensor is on AND fired within the last 5 minutes
                  if StateStore.on?(id) and ts - last_ts < 300 do
                    ["pir_active(\"#{room}\", #{last_ts})."]
                  else
                    []
                  end

                :not_found ->
                  []
              end
          end

        door_line =
          case RoomConfig.door_entity(room) do
            nil -> []
            id -> if not StateStore.on?(id), do: ["door_closed(\"#{room}\", #{ts})."], else: []
          end

        mmwave_line ++ pir_line ++ door_line
      end)

    (lines ++ sensor_lines) |> Enum.join("\n")
  end

  defp presence_confidence_facts do
    lines =
      ["// jinvi — fused presence confidence (0-100)",
       ".decl room_occupied_confidence(room: symbol, confidence: number)",
       ".decl room_epistemic_type(room: symbol, etype: symbol)"]

    confidence_lines =
      Enum.flat_map(RoomConfig.rooms(), fn room ->
        try do
          {score, etype} = PresenceFusion.read(room)

          [
            "room_occupied_confidence(\"#{room}\", #{score}).",
            "room_epistemic_type(\"#{room}\", \"#{etype}\")."
          ]
        catch
          _, _ -> []
        end
      end)

    (lines ++ confidence_lines) |> Enum.join("\n")
  end

  defp schedule(interval), do: Process.send_after(self(), :generate, interval)
end
